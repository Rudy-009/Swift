# Overview

동시성 코드를 실행하다 보면 여러가지 문제가 발생할 수 있습니다. 동시적으로 같은 메모리 주소에 접근하거나, 서로가 자원을 점유한 채 서로의 자원을 기다리는 상황이 생길 수 있습니다. 이러한 문제를 안전하게 처리할 수 있는 상태를 `Thread Safety(쓰레드 안정성)` 라고 합니다.

Swift 5.5에서 등장한 Swift Concurrency는 이러한 문제를 예방하고자 여러 프로토콜과 타입을 제공합니다. 덕분에 많은 동시성 문제를 컴파일 단계에서 미리 잡아 낼 수 있게 되었고 런타임 에러 발생 가능성을 줄일 수 있게 되었습니다. 오늘은 Swift Concurrency 자체를 다루지 않고, 추후 별도의 포스트에서 다뤄보겠습니다.

# 동시성 관련 문제

우선, 동시성 관련해서 어떤 문제들이 발생할 수 있는지 알아보겠습니다.

## 경쟁 상황 (Race Condition)

- 타이밍이나 이벤트의 순서로 인해 코드의 명확성에 영향을 주는 경우 발생하는 경우를 말합니다. 동시성 프로그래밍으로 인해 이벤트의 순서가 보장되지 않아 결과를 예측할 수 없는 경우라고 이해됩니다.

## Data Race

- 쓰레드가 다른 쓰레드가 쓰기 작업 중인 메모리 주소에 접근할 때 발생하는 현상입니다. 자주 쓰는 예시인 은행 잔고 계산을 생각해본다면, 잔고 100에서 프로세스 A는 송금 50, 프로세스 B는 50입금을 담당합니다.

```
- A : 잔고 100 읽기
- A : -50
- A : 잔고 50 쓰기
- B : 잔고 50 읽기
- B : + 50
- B : 잔고 100 쓰기

결과 100
```

이런 순서로 되어야 하는데, 동시에 쓰기 작업을 하게 되어서 결과가 꼬이는 경우입니다.

```
- A : 잔고 100 읽기
- B : 잔고 100 읽기
- A : -50
- A : 잔고 50 쓰기
- B : + 50
- B : 잔고 150 쓰기

결과 150
```

[Race Condition vs Data Race 참고](https://www.avanderlee.com/swift/race-condition-vs-data-race/)

저희가 앞으로 주로 보게될 예시는 Data Race라고 알아두시면 좋을거 같습니다.

## 교착 상태 (DeadLock)

시스템 자원에 대한 요구가 엉킨 상태를 데드락이라고 합니다.

예를 들면, 프로세스 A와 B 각각 자원 X, Y를 점유하고 있습니다. A는 자원 Y가 해제되기를 기다리는 중이며, B는 자원 X가 해제 되기를 기다리는 중입니다. 그렇게 되면 무한 대기에 빠지게 됩니다.

## 우선 순위 역전 (Priority Inversion)

낮은 우선 순위의 작업이 자원을 배타적으로 사용하고 있을 때, 작업의 우선순위가 바뀌는 경우

이는, GCD가 낮은 우선순위의 작업의 우선순위를 (임시로) 높여서 빨리 동작시킬 수 있습니다.

# Thread Safety

**Thread Safety** 란? 멀티 쓰레드 환경에서 프로그램이 예측 가능한 방식으로 동작하는 상태입니다.

다음 시간에는 시리얼 큐와 sync, Dispatch Barrier로 Thread Safe Code 를 작성하는 방법을 알아보겠습니다.